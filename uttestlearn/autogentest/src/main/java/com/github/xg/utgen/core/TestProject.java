package com.github.xg.utgen.core;

import com.github.xg.utgen.AsyncGUINotifier;
import com.github.xg.utgen.core.dependency.ExcludeMockStrategy;
import com.github.xg.utgen.core.dependency.MavenDependencyParser;
import com.github.xg.utgen.core.model.ClassInfo;
import com.github.xg.utgen.core.model.GenerateStatus;
import com.github.xg.utgen.core.model.TestProjectInfo;
import com.github.xg.utgen.core.util.ExtClassPathLoader;
import com.github.xg.utgen.core.util.PomFinder;
import com.github.xg.utgen.core.util.StrKit;
import com.google.common.base.Joiner;
import com.google.common.base.Strings;

import java.io.BufferedReader;
import java.io.File;
import java.io.InputStreamReader;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.concurrent.TimeUnit;

import static com.github.xg.utgen.core.util.Formats.RT_1;

/**
 * Created by yuxiangshi on 2017/8/14.
 */
public final class TestProject {

    private List<String> pomPaths;
    private List<String> pomWithSrcPaths;
    private Map<String, List<String>> srcPathClassesMap = new HashMap<>();
    private ImplementFinder implementFinder;
    private String loacalRepoPath;
    private String projectName;
    private StringBuilder errors = new StringBuilder();
    private String[] addClassPaths;
    private int newCnt = 0;
    private int updateCnt = 0;
    private int testCaseCnt = 0;
    static Boolean preferConstructorWithParams;
    private String[] includeGeneratePackages;
    private String[] excludeGeneratePackages;
    private String cmdTarget;
    Boolean closeMock;
    Boolean singleTestcase;
    private String outputPath;
    Boolean closeDefaultCallToFail;
    Boolean closeFieldSetGetCode;
    private AsyncGUINotifier notifier;
    private Set<String> subModules;

    public void setNotifier(AsyncGUINotifier notifier) {
        this.notifier = notifier;
    }

    String getHEADER() {
        return "/**" + RT_1
                + " *" + " Generated by UT-Plugin on " + new SimpleDateFormat("yyyy/MM/dd HH:mm").format(new Date()) + "." + RT_1
                + " */" + RT_1;
    }

    public TestProject(TestProjectInfo projectInfo) {
        this.projectName = projectInfo.getProjectPath();
        this.loacalRepoPath = projectInfo.getLocalRepoPath();
        this.addClassPaths = projectInfo.getAddClassPaths();
        this.includeGeneratePackages = projectInfo.getIncludeGeneratePackages();
        this.excludeGeneratePackages = projectInfo.getExcludeGeneratePackages();
        this.cmdTarget = projectInfo.getCmdTarget();
        this.closeMock = projectInfo.getCloseMock();
        this.singleTestcase = projectInfo.getSingleTestcase();
        this.outputPath = projectInfo.getOutputPath();
        this.closeDefaultCallToFail = projectInfo.getCloseDefaultCallToFail();
        this.closeFieldSetGetCode = projectInfo.getCloseFieldSetGetCode();

        if (projectInfo.getFileSuffix() != null) {
            String s = projectInfo.getFileSuffix().trim();
            if ("".equals(s)) {
                s = "Auto";
            } else if ("blank".equals(s)) {
                s = "";
            }
            TestClassCodeGenerate.SUFFIX = s + "Test";
            MockCodeGenerate.suffix = s + "Mock";
        }
        preferConstructorWithParams = projectInfo.getPreferConstructorWithParams();
        ExcludeMockStrategy.addPackages(projectInfo.getExcludeMockPackages());
        ExcludeMockStrategy.addMethodPrefix(projectInfo.getExcludeMockMethodPrefixes());
        ExcludeMockStrategy.addMethodSuffix(projectInfo.getExcludeMockMethodSuffixes());
        ExcludeMockStrategy.addPackageMethodPrefix(projectInfo.getExcludeMockPackageMethodPrefixes());
        ExcludeMockStrategy.addPackageMethodSuffix(projectInfo.getExcludeMockPackageMethodSuffixes());
        ExcludeMockStrategy.addOnlyIncludeMockPackageMethods(projectInfo.getOnlyIncludeMockPackageMethods());
        PomFinder fp = new PomFinder();
        pomPaths = fp.getAllPomFiles(projectInfo.getProjectPath());
        pomWithSrcPaths = fp.getAllPomFilesWithSrc(projectInfo.getProjectPath());

        pomWithSrcPaths.forEach(path -> {
            classNames = new ArrayList<>();
            findAllClassNames(new File(path + "\\src\\main\\java\\"));
            srcPathClassesMap.put(path, classNames);
        });
        implementFinder = new ImplementFinder(srcPathClassesMap);
    }

    private boolean skipOrNot(String className) {
        if (!className.contains(".")) {
            notifier.failed("Class without package name is not supported: " + className);
            return true;
        }
        boolean skip;
        if (!StrKit.blank(cmdTarget)) {
            skip = true;
            String simpleName = null;
            try {
                simpleName = className.substring(className.lastIndexOf('.') + 1);
            } catch (Exception e) {
                //ignore
            }
            String[] names = cmdTarget.split(",");
            for (String name : names) {
                if (className.startsWith(name) || (simpleName != null && simpleName.startsWith(name))) {
                    skip = false;
                    break;
                }
            }
            return skip;
        }

        if (!elementsNullOrEmpty(includeGeneratePackages) && elementsNullOrEmpty(excludeGeneratePackages)) {
            skip = true;
            for (String includeGeneratePackage : includeGeneratePackages) {
                if (includeGeneratePackage != null) {
                    if (className.startsWith(includeGeneratePackage)) {
                        skip = false;
                    }
                }
            }
        } else if (!elementsNullOrEmpty(excludeGeneratePackages) && elementsNullOrEmpty(includeGeneratePackages)) {
            skip = false;
            for (String excludeGeneratePackage : excludeGeneratePackages) {
                if (excludeGeneratePackage != null) {
                    if (className.startsWith(excludeGeneratePackage)) {
                        skip = true;
                    }
                }
            }

        } else if (!elementsNullOrEmpty(includeGeneratePackages) && !elementsNullOrEmpty(excludeGeneratePackages)) {
            skip = true;
            for (String includeGeneratePackage : includeGeneratePackages) {
                if (includeGeneratePackage != null) {
                    if (className.startsWith(includeGeneratePackage)) {
                        skip = false;
                    }
                }
            }
            for (String excludeGeneratePackage : excludeGeneratePackages) {
                if (excludeGeneratePackage != null) {
                    if (className.startsWith(excludeGeneratePackage)) {
                        skip = true;
                    }
                }
            }

        } else {
            skip = false;
        }
        return skip;
    }

    private boolean elementsNullOrEmpty(String[] strings) {
        if (strings == null) {
            return true;
        }
        for (String string : strings) {
            if (!Strings.isNullOrEmpty(string)) {
                return false;
            }
        }
        return true;
    }

    public void generateTestSources(Set<String> modules, boolean interactiveMock) throws Exception {
        this.subModules = modules;
        resolveProject(modules);

        log("Analyze project's dependencies success");
        log("\nStart generating test code...");

        Map<String, List<String>> filteredMap = new HashMap<>();
        for (Map.Entry<String, List<String>> entry : srcPathClassesMap.entrySet()) {
            if (modules.contains(entry.getKey())) {
                filteredMap.put(entry.getKey(), entry.getValue());
            }
        }

        for (Map.Entry<String, List<String>> entry : filteredMap.entrySet()) {
            String rootPath = entry.getKey();
            List<String> classes = entry.getValue();
            for (String className : classes) {
                if (skipOrNot(className)) {
                    continue;
                }
                String classPath = rootPath + "\\target\\classes";
                String srcPath = rootPath + "\\src\\main\\java\\" + Joiner.on("\\").join(className.split("\\.")) + ".java";
                ClassInfo classInfo = new ClassInfo(className, classPath, srcPath);

                String savePathPrefix = rootPath + "\\src\\test\\java\\";
                if (!StrKit.blank(outputPath)) {
                    if (!outputPath.endsWith("\\")) {
                        outputPath += "\\";
                    }
                    savePathPrefix = outputPath;
                }
                String savePath = savePathPrefix + Joiner.on("\\").join(className.split("\\.")) + TestClassCodeGenerate.SUFFIX + ".java";
                TestClassCodeGenerate testClass = new TestClassCodeGenerate(this, classInfo, implementFinder);
                String prefix = "Generate ";
                try {
                    testClass.generateTestSource(savePath, interactiveMock);
                    GenerateStatus status = testClass.getStatus();
                    testCaseCnt += testClass.getTestCaseCnt();

                    switch (status) {
                        case NewCreate:
                            newCnt++;
                            break;
                        case Update:
                            updateCnt++;
                            prefix = "Update ";
                            break;
                        default:
                            break;
                    }

                    if (status != GenerateStatus.None) {
                        log(prefix + classInfo.getClassFullName() + TestClassCodeGenerate.SUFFIX + " success");
                    }
                } catch (Throwable e) {
                    String errorInfo = String.valueOf(e);
                    if (errors.length() < 10000) {
                        errors.append("----------------------------------");
                        errors.append(errorInfo);
                        errors.append("\r\n");
                        errors.append(Arrays.toString(e.getStackTrace()));
                        errors.append("\r\n");
                    }
                    log(prefix + savePath + " failed, errorInfo: " + errorInfo);
                }
            }
        }
        collect();
    }

    private void resolveProject(Set<String> modules) throws Exception {
        String parentPomPath = PomFinder.getParentPomPath(pomPaths);
        List<String> list = pomWithSrcPaths;
        if (parentPomPath != null) {
            list = new ArrayList<>();
            list.add(parentPomPath);
            list.addAll(pomWithSrcPaths);
        }

        List<String> selectedDirectories = new ArrayList<>();
        list.forEach(item -> {
            for (String module : modules) {
                if (module.startsWith(item)) {
                    selectedDirectories.add(item);
                    break;
                }
            }
        });

        // 依赖文件都存在，并且最旧的比最新的pom.xml新
        long oldestDependencyFileModifiedTime = Long.MAX_VALUE;
        long newestPomFileModifiedTime = Long.MIN_VALUE;

        for (String selectedDirectory : selectedDirectories) {
            String dependencyFile = "C:\\ut-maven-plugin\\" + selectedDirectory.substring(selectedDirectory.lastIndexOf("\\") + 1) + ".txt";
            long lastModified = new File(dependencyFile).lastModified();
            if (lastModified < oldestDependencyFileModifiedTime) {
                oldestDependencyFileModifiedTime = lastModified;
            }

            long pomLastModified = new File(selectedDirectory + "\\pom.xml").lastModified();
            if (pomLastModified > newestPomFileModifiedTime) {
                newestPomFileModifiedTime = pomLastModified;
            }
        }

        boolean notAnalyzeDependency = oldestDependencyFileModifiedTime > newestPomFileModifiedTime;
        notifier.printOnConsole("Local maven repository path: " + loacalRepoPath + "\n\n");
        List<String> dependencyFiles = new ArrayList<>();

        for (String dir : selectedDirectories) {
            try {
                String moduleName = dir.substring(dir.lastIndexOf("\\") + 1);
                log("Compile " + moduleName + " and analyze its dependencies...");

                String dependencyFile = "C:\\ut-maven-plugin\\" + moduleName + ".txt";
                dependencyFiles.add(dependencyFile);

                ProcessBuilder builder = new ProcessBuilder();
                builder.directory(new File(dir));

                List<String> cmds = new ArrayList<>();
                cmds.add("cmd.exe");
                cmds.add("/c");
                String mvnCmd = "mvn compile && mvn dependency:list -DoutputFile=" + dependencyFile;
                if (notAnalyzeDependency) {
                    mvnCmd = "mvn compile";
                }
                cmds.add(mvnCmd);
                builder.command(cmds);
                //print cmd
                log("Executing command \"" + mvnCmd + "\" in " + dir);
                Process process = builder.start();
                //notifier.attachProcess(process);

                InputStreamReader reader = new InputStreamReader(process.getInputStream());
                BufferedReader bufferedReader = new BufferedReader(reader);

                boolean compileSuccess = true;
                String line;
                StringBuilder sb = new StringBuilder();
                while ((line = bufferedReader.readLine()) != null) {
                    sb.append(line + "\n");
                    if (line.contains("[ERROR]")) {
                        compileSuccess = false;
                    }
                }
                process.waitFor();
                if (!compileSuccess) {
                    log(sb.toString());
                    throw new Exception("编译失败，请检查项目，单个module编译失败时请先对整个project进行mvn install -DskipTests");
                }
            } catch (Exception e) {
                throw new Exception(e.getMessage());
            }
        }

        int tryCnt = 0;
        while (true) {
            if (allComplete(dependencyFiles)) {
                break;
            }
            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {

            }
            if (tryCnt++ > 12) {
                throw new RuntimeException("Analyze project's dependency failed, please check if the project could be successfully compiled");
            }
        }

        if (addClassPaths != null) {
            for (String addClassPath : addClassPaths) {
                ExtClassPathLoader.addClassPath(addClassPath);
            }
        }

        pomWithSrcPaths.forEach(path -> ExtClassPathLoader.addClassPath(path + "\\\\target\\\\classes"));
        MavenDependencyParser parser = new MavenDependencyParser(dependencyFiles, loacalRepoPath);
        List<String> dependencyClassPaths = parser.getDependencyPaths();
        dependencyClassPaths.forEach(path -> ExtClassPathLoader.addClassPath(path));
    }

    private List<String> classNames;
    private List<String> currentPath = new ArrayList<>();

    private void findAllClassNames(File file) {
        currentPath.add(file.getName());
        if (file.isDirectory()) {
            for (File f : file.listFiles()) {
                findAllClassNames(f);
            }
        } else if (file.getName().endsWith(".java")) {
            String fileName = Joiner.on(".").join(currentPath).substring(5);
            String className = fileName.substring(0, fileName.length() - 5);
            classNames.add(className);
        }
        currentPath.remove(currentPath.size() - 1);

    }

    private boolean allComplete(List<String> files) {
        for (String file : files) {
            if (!new File(file).exists()) {
                return false;
            }
        }
        return true;
    }

    private void collect() {
        if (newCnt + updateCnt == 0) {
            log("\nNothing to generate or update");
        } else {
            if (newCnt > 0) {
                log("\nSuccessfully generated " + newCnt + " test class" + (newCnt == 1 ? "" : "es"));
            }
            if (updateCnt > 0) {
                log("\nSuccessfully updated " + updateCnt + " test class" + (updateCnt == 1 ? "" : "es"));
            }
        }
    }

    private void log(String msg) {
        notifier.printOnConsole(msg);
        notifier.printOnConsole("\n");
    }

}
